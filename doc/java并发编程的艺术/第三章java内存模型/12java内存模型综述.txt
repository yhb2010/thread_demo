顺序一致性内存模型是一个理论参考模型，jmm和处理器内存模型在设计时通常会以顺序一致性内存模型为参照。在设计时，jmm和处理器内存模型会对顺序一致性模型做一些
放松，因为如果完全按照顺序一致性模型来实现处理器和jmm，那么很多的处理器和编译器优化都要被禁止，这对执行性能将会有很大影响。

jmm的内存可见性保障：
	1、单线程程序：单线程程序不会出现内存可见性问题。编译器、处理器会共同确保单线程程序的执行结果与该线程在顺序一致性模型中的执行结果相同。
	2、正确同步的多线程程序：它的执行将具有顺序一致性（程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同）。这是jmm关注的重点。jmm通过限制
	编译器和处理器的重排序来为程序员提供内存可见性保证。
	3、未同步/未正确同步的多线程程序：jmm为他们提供了最小安全性保障：线程执行时读取到的值，要么是之前某个线程写入的值，要么是默认值（nullk、0、false）
	。

注意，最小安全性保障与64位数据的非原子性写并不矛盾。他们是两个不同的概念，他们发生的时间点也不同。最小安全性保证对象默认初始化之后(设置成员域为0、null、
false)，才会被任意线程使用。最小安全性发生在对象被任意线程使用之前。64位数据的非原子性写发生在对象被多个线程使用的过程中(写共享变量)。当发生问题时（
处理器b看到仅仅被处理器a写了一半的无效值），这里虽然处理器b读取到了一个被写入一半的无效值，但这个值仍然是处理器a写入的，只不过是处理器a还没有写完而已。
最小安全性保证线程读取到的值，要么是之前某个线程写入的值，要么是默认值。但最小安全性并不保证线程读取到的值，一定是某个线程写完后的值。最小安全性保证线程
读取到的值不会无中生有的冒出来，但并不保证线程读取到的值一定是正确的。

jdk对旧内存模型的修补：
	1、增强volatile的内存语义。旧内存模型允许volatile变量与普通变量重排序。jsr-133严格限制volatile变量与普通变量的重排序，使volatile的写-读和
	锁的释放-获取具有相同的内存语义。
	2、增强final的内存语义。在旧内存模型中，多次读取同一个final变量的值可能会不相同。为此，jsr-133为final增加了两个重排序规则。在保证final引用不会
	从构造函数内逸出的情况下，final具有了初始化安全性。