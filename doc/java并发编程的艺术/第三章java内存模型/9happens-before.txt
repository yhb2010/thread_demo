在设计jmm时需要考虑两个因素：
	1、程序员对内存模型的使用。程序员希望内存模型易于理解、易于编程。希望基于一个强内存模型来编写代码。
	2、编译器和处理器对内存模型的实现。编译器和处理器希望内存模型对他们的束缚越少越好。这样他们就可以做尽可能多的优化来提高性能。他们希望
	实现一个弱内存模型。

double pi = 3.14//A
double r = 1.0//B
double area = pi * r* r//C
上面存在3个happens-before关系：
	1、A happens-before B
	2、B happens-before C
	3、 A happens-before C
	其中2,3是必须的，但1是不必要的。因此jmm把happens-before要求禁止的重排序分为两类：
	1、会改变程序执行结果的重排序。
	2、不会改变程序执行结果的重排序。
	jmm对这两种不同性质的重排序，采取了不同的策略：
	1、对于会改变程序执行结果的重排序，jmm要求编译器和处理必须禁止这种重排序。
	2、对于不会改变程序执行结果的重排序，jmm对编译器和处理不做要求。

jmm设计图：
					     程序员（程序员基于happens-before规则提供的内存可见性保证来编程）
				happens-before规则
		要求禁止						要求禁止
	会改变程序执行结果				不会改变程序执行
	的重排序						结果的重排序（程序员以为jmm禁止了这种重排序，但实际上jmm没有这么做）
要求禁止			要求禁止
编译器			处理器

jsr-133对happens-before关系的定义：
	1、如果一个操作happens-before另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
	2、两个操作之间存在happens-before关系，并不意味着java平台的具体实现必须要按照happens-before关系指定的顺序来执行。如果重排序之后的执行结果，与按
	happens-before关系来执行的结果一致，那么这种重排序并不非法（也就是说，jmm允许这种重排序）。