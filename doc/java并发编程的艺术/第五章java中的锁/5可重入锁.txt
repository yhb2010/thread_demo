ReentrantLock在调用lock()方法时，已经获取了锁的线程，能够再次调用lock方法获取锁而不被阻塞。

重进入是指任意线程在获取到锁之后，能够再次获取该锁而不会被阻塞，该特性的实现需要解决两个问题：
	1、线程再次获取锁：锁需要去识别获取锁的线程是否为当前占据锁的线程，如果是，则再次成功获取。
	2、锁的最终释放：线程重复n次获取了锁，随后在第n次释放该锁后，其它线程能够获取到该锁，锁的最终释放要求所对于获取进行技术自增，计数表示当前锁被重复获取
	的次数，而锁被释放时，计数自减，当计数等于0时表示锁已经成功释放。

公平性锁保证了锁的获取按照fifo原则，而代价是进行大量的线程切换，非公平锁虽然可能造成线程饥饿，但极少的线程切换，保证了其更大的吞吐量。