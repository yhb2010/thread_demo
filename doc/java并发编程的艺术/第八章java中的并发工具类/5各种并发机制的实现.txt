体会到锁带来的甜头以后， 各种各样样的需求纷至沓来： 
	1. 有时候需要多个线程都获得同一把锁，去做一件事情，那怎么办呢？
	没关系，信号量（Semaphore）出马，创建信号量的时候得指定一个整数(例如10)， 表明同一时刻最多有10个线程可以获得锁： 
	Semaphore lock= new Semaphore(10);
	当然每个线程都需要调用lock.aquire(), lock.release()去申请/释放锁。 

	2.  一个线程要写共享变量， 可是还有几个线程要同时读， 怎么办？ 你写的时候可以锁住， 但总不能读的时候也只允许一个线程吧？  
	只好来一个读写锁了ReadWriteLock， 为了保证可重入性， 元老院体贴的实现了ReentrantReadWriteLock。

	3. 一个线程需要等待其他多个线程完工以后才能干活，怎么办？ 
	CountDownLatch前来救驾， 搞一个计数器，某个线程干完了就把计数器减去1， 如果计数器为0了，那个一直耐心等待的线程就可以开始了。

	4. 还有几个线程必须互相等待， 就像100米赛跑那样， 所有人都准备好了才能开闸放水， 不，是起跑， 就那就赏你一个CyclicBarrier吧。