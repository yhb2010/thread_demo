线程池类其实就是一种生产者好消费者模式的实现方式，但是我觉得其实现方式更加高明。生产者把任务丢给线程池，线程池创建线程并处理任务，如果将要
运行的任务数大于线程池的基本线程数就把任务扔到阻塞队列里，这种做法比只使用一个阻塞队列来实现生产者和消费者模式显然要高明很多，因为消费者能
够处理就处理掉了，这样速度更快，而生产者先存，消费者再取这种方式显然慢一些。

我们的系统也可以使用线程池来实现多生产者和消费者模式。例如，创建n个不同规模的线程池来处理不同性质的任务，比如线程池1将数据读取到内存之后，
交给线程池2里的线程继续处理压缩数据。线程池1主要处理io密集型任务，线程池2主要处理cpu密集型任务。

读者可以在平时的工作中思考一下哪些场景可以使用生产者和消费者模式，这种场景会很多，特别是需要处理任务时间比较长的场景。比如上传附件并处理，
用户把文件上传到系统后，系统把文件丢到队列里，然后立刻返回告诉用户上传成功，最后消费者再去队列里取出文件处理。再如，调用一个远程接口查询
数据，如果远程服务接口查询时需要几十秒的时间，那么它可以提供一个申请查询的接口，这个接口把要申请的查询任务放到数据库中，然后该接口立刻返
回。然后服务器端用线程轮询并获取申请任务进行处理，处理完之后发消息给调用方，让调用方再来调用另外一个接口取数据。