1、减小锁的持有时间
2、减小锁粒度：
	就是指缩小锁定对象范围，从而减少锁冲突的可能性，进而提高系统的并发能力。
	例如ConcurrentHashMap。但是减少锁粒度会引入一个新的问题，即当系统需要取得全局锁时，其消耗的资源会比较多。如size方法，他将返回
		ConcurrentHashMap的有效表项的数量，要获取这个信息需要取得所有子段的锁。
		sum=0;
		for(int i=0;i<segments.length;i++){
			segments[i].lock();
		}
		for(int i=0;i<segments.length;i++){
			sum+=segments[i].count;
		}
		for(int i=0;i<segments.length;i++){
			segments[i].unlock();
		}
	可以看到在计算总数时，需要先获得所有段的锁，然后求和。事实上，ConcurrentHashMap的size方法会先使用无锁的方式求和，如果失败，再
	使用加锁的方法，但是在高并发下还是比HashMap差。因此，只有在size等获取全局信息的方法调用并不频繁时，这种方法才能真正意义上提高性
	能。
3、读写分离锁替换独占锁
4、锁分离：
	例如LinkedBlockingQueue，它的take和put方法分别作用于队列的前端和尾端，从理论上说，两者并不冲突。因此可以使用两把不同的锁，分
	离了take和put操作。
5、锁粗化：
	为了保证多线程间的有效并发，会要求每个线程持有锁的时间尽量短，即在使用完公共资源后，立即释放锁。只有这样，等待在这个锁上的其它线
	程才能尽快获得资源执行任务，但是对同一个锁不停的进行请求、同步和释放，其本身也会消耗系统资源，反而不利于性能优化。
	为此，虚拟机在遇到一连串连续对同一锁不断进行请求和释放的操作时，会把所有锁操作整合成对锁的一次请求，从而减少对锁的请求同步次数，
	这叫做锁的粗化，比如在循环里获取、释放同一个锁。