锁偏向
	是一种加锁操作的优化手段,他的核心思想是:如果一个线程获得了锁,那么就进入偏向模式,当这个线程再次请求锁时,无须在做任何同步操作,因此
	在几乎没有锁竞争的场合,偏向锁是比较好的优化效果,因为连续多次极有可能是同一个线程请求同一个相同的锁,对于锁竞争比较激烈的场合,其效
	果不佳,因为竞争激烈的场合,最有可能的情况是每次都是不同的线程来请求相同的锁,这样偏向模式就会失效,使用Java虚拟机参数
	-XX:+UseBiasedLocking可以开启偏向锁,
轻量级锁
	如果偏向锁失败,虚拟机并不会立即挂起线程,他还会使用一种称为轻量级锁的优化手段,轻量级锁的操作也很方便,它只是简单地将对象头部作为指
	针,指向持有锁的线程堆栈内部,来判断一个线程是否持有对象锁,如果线程获取轻量级锁成功,则可以顺利进入临界区,如果轻量级锁加锁失败,则表
	示其他线程抢险争夺到了锁,那么当前线程的锁请求就会膨胀为重量级锁
自旋锁
	锁膨胀后,虚拟机为了避免线程真实的在操作系统层面挂起,虚拟机还会在做最后的努力,自旋锁,由于当前线程暂时无法获得锁,但什么时候可以获
	得锁是一个未知数,也许几个cpu时钟周期,就可以得到锁,如果这样,简单粗暴地挂起线程可能是一种得不偿失的操作,因此,系统会进行一次赌注,
	他会假设在不久的将来,线程可以得到这把锁,因此,虚拟机会让当前线程做几个空循环,在经过若干次循环后,如果可以得到锁,那么就顺利进入临界
	区,如果还是得不到锁,才会真实地将线程在操作系统层面挂起,
锁消除
	锁消除是一种更彻底的锁优化,Java虚拟机在Jit编译时,通过对运行上下文的扫描,去除不可能存在共享资源竞争的锁,通过锁消除,可以节省毫无
	意义的请求锁的时间,如果不可能存在竞争,为什么还要加锁呢?这是因为咋Java软件开发过程中,我们必然会使用一些JDK的内置API,比如
	StringBuffer,Vector等,你在使用的时候,也许根本不会考虑这些对象内部是如何实现的,但是真实环境中,缺不存在竞争,如果虚拟机检测到这
	种情况,就会将这些无用的锁操作去除,
		public String[] createStrings() {
		    Vector<String> v = new Vector<>();
		    for (int i = 0; i < 100; i++) {
		        v.add(Integer.toString(i));
		    }
		    return v.toArray(new String[]{});
		}
	锁消除涉及一项关键技术为逃逸分析,所谓逃逸分析就是观察某一个变量是否会逃出某一个作用域,在本例子中,变量v显然没有逃出
	createStrings()方法之外,以此为基础,虚拟机才可以大胆地将v内部的加锁操作去除,
	逃逸分析必须在-server模式下进行,可以使用-XX:+DoEscapeAnalysis参数打开逃逸分析.使用-XX:+EliminateLocks参数可以打开锁消
	除.