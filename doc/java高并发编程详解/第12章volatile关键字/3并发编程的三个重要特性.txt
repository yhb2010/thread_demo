1、原子性：
	指在一次的操作或多次操作中，要么所有操作全部得到了执行并且不受到任何因素的干扰而中断，要么所有的操作都不执行，说起原子性一般都会用银行转账来进行
	举例说明。
	注意：两个原子性的操作结合在一起未必还是原子性的，比如i++(其中get i，i+1和set i=x三者都是原子性操作，但是不代表i++就是原子性操作)
	volatile关键字不保证数据的原子性，synchronized关键字保证，自jdk1.5之后，其提供的原子类型变量也可以保证原子性。
2、可见性：
	当一个线程对共享变量进行了修改，那么另外的线程可以立即看到修改后的最新值
3、有序性：
	程序代码在执行过程中的先后顺序，由于java编译器以及运行期的优化，导致了代码的执行顺序未必就是开发者编写代码时的顺序。在单线程下，无论怎么重排序
	最终都会保证程序的执行结果和代码顺序执行的结果完全一样，但是多线程下，如果有序性得不到保证，可能会出现大问题：
	private boolean init = false;
	private Context c;
	public Context load(){
		if(!init){
			c = loadContext();
			init = true;
		}
		return c;
	}
	上面程序使用变量init控制c的加载，如果多线程下发生了重排序，比如c = loadContext();排到了init = true;的后面，那么第一个线程先
	判断init=false，因此准备执行context的加载，但是他在执行loadContext方法前先将init置为true，那么第二个线程此时也执行load方
	法，会发现init为true，则直接返回了一个未被加载的context。