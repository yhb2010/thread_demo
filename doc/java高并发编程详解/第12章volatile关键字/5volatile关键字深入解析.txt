volatile关键字修饰的变量具有两层语义：
	1、保证了不同线程之间对共享变量操作时的可见性，也就是说当一个线程修改volatile修饰的变量，另外一个线程会立即看到最新的值
	2、禁止对指令进行重排序操作
	
理解volatile保证可见性：
	结合一个线程reader，一个线程updater的例子
	1、Reader线程从主内存中获取init的值为0，并且将其缓存到本地工作内存中2
	2、updater线程将init的值在本地工作内存中修改为1，然后立即刷新至主内存中
	3、reader线程的本地工作内存的init失效
	4、由于reader线程工作内存种的init失效，因此需要到主内存中重新读取init的值
	
理解volatile保证顺序性：
	直接禁止jvm和处理器对volatile关键字修饰的指令重排序，但是对于volatile前后无依赖关系的指令则可以重排序，比如：
	int x=0;
	int y=1;
	volatile int z=20;
	x++;
	y--;
	在语句volatile int z=20;之前，先执行x的定义还是y的定义，我们并不关系，只要能够保证在执行到z=20的时候x=0，y=1
	即可，同理关于x的自增以及y的自减操作都必须在z=20之后才能发生。
	
volatile关键字源码：我们发现被volatile修饰的变量存在一个lock;的前缀，lock;前缀实际上相当于一个内存屏障，该屏障会为指令的
执行提供如下几个保障：
	1、确保指令重排序时不会将其后面的代码排到内存屏障之前
	2、确保指令重排序时不会将其前面的代码排到内存屏障之后
	3、确保在执行到内存屏障修饰的指令时前面的代码全部执行完成
	4、强制将线程工作内存中值的修改刷新至主内存中
	5、如果是写操作，则会导致其他线程工作内存(cpu cache)中的缓存数据失效