1、交叉锁可导致程序出现死锁：
	线程a持有r1的锁等待获取r2的锁，线程b持有r2的锁等待获取r1的锁
2、内存不足：
	当并发请求系统可用内存时，如果此时系统内存不足，则可能会出现死锁，比如，两个线程a，b，执行某个任务，其中a已经获得了10m内存，a获得了20m
	内存，如果每个线程的执行单元都需要30m内存，而剩余的可用内存只有20m，那么两个线程可能都在等待彼此能够释放内存资源
3、一问一答式的数据交换：
	服务端开启某个端口，等待客户端访问，客户端发送请求立即等待接收，由于某种原因服务端错过了客户端的请求，仍然在等待一问一答式的数据交换，此时服务
	端和客户端都在等待着双方发送数据
4、数据库锁：
	无论是数据库表级别的锁，还是行级别的锁，比如某个线程执行for update语句退出了事务，其它线程访问该数据库时都将陷入死锁
5、文件锁：
	同理，某个线程获得了文件锁以外退出，其它读取该文件的线程也将会陷入死锁直到系统释放文件句柄资源
6、死循环引起的死锁：
	程序由于代码原因或者对某些异常处理不当，进入了死循环，虽然查看线程堆栈信息不会发现任何死锁的迹象，但是程序不工作，cpu占用极高，这种死锁称为系
	统假死，是一种最为最为致命的死锁现象，由于重现困难，进程对cpu的使用量又达到极限，想要做出dump有时候也是非常困难的